/**
 * Generated by orval v7.11.2 ðŸº
 * Do not edit manually.
 * Login API
 * Simple login API using JWT
 * OpenAPI spec version: 1.0.0
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import {
  faker
} from '@faker-js/faker';

import {
  HttpResponse,
  delay,
  http
} from 'msw';

import { axios } from './axios';
export interface RegisterRequest {
  email: string;
  /** @minLength 6 */
  password: string;
}

export interface LoginRequest {
  email: string;
  password: string;
}

export interface TokenResponse {
  accessToken?: string;
  refreshToken?: string;
}

export interface RefreshRequest {
  refreshToken: string;
}

export interface MeResponse {
  id?: string;
  email?: string;
}

export interface ErrorResponse {
  message?: string;
  error?: string;
}

export interface LogoutRequest {
  /** The refresh token to invalidate */
  refreshToken: string;
}

export interface LogoutResponse {
  message?: string;
}

export type PostApiAuthRefresh200 = {
  accessToken?: string;
};

/**
 * @summary Register a new user
 */
export const postApiAuthRegister = (
    registerRequest: RegisterRequest,
 signal?: AbortSignal
) => {
      
      
      return axios<TokenResponse>(
      {url: `/api/auth/register`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: registerRequest, signal
    },
      );
    }
  


export const getPostApiAuthRegisterMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postApiAuthRegister>>, TError,{data: RegisterRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof postApiAuthRegister>>, TError,{data: RegisterRequest}, TContext> => {

const mutationKey = ['postApiAuthRegister'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postApiAuthRegister>>, {data: RegisterRequest}> = (props) => {
          const {data} = props ?? {};

          return  postApiAuthRegister(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostApiAuthRegisterMutationResult = NonNullable<Awaited<ReturnType<typeof postApiAuthRegister>>>
    export type PostApiAuthRegisterMutationBody = RegisterRequest
    export type PostApiAuthRegisterMutationError = ErrorResponse

    /**
 * @summary Register a new user
 */
export const usePostApiAuthRegister = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postApiAuthRegister>>, TError,{data: RegisterRequest}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postApiAuthRegister>>,
        TError,
        {data: RegisterRequest},
        TContext
      > => {

      const mutationOptions = getPostApiAuthRegisterMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary Login with email and password
 */
export const postApiAuthLogin = (
    loginRequest: LoginRequest,
 signal?: AbortSignal
) => {
      
      
      return axios<TokenResponse>(
      {url: `/api/auth/login`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: loginRequest, signal
    },
      );
    }
  


export const getPostApiAuthLoginMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postApiAuthLogin>>, TError,{data: LoginRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof postApiAuthLogin>>, TError,{data: LoginRequest}, TContext> => {

const mutationKey = ['postApiAuthLogin'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postApiAuthLogin>>, {data: LoginRequest}> = (props) => {
          const {data} = props ?? {};

          return  postApiAuthLogin(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostApiAuthLoginMutationResult = NonNullable<Awaited<ReturnType<typeof postApiAuthLogin>>>
    export type PostApiAuthLoginMutationBody = LoginRequest
    export type PostApiAuthLoginMutationError = ErrorResponse

    /**
 * @summary Login with email and password
 */
export const usePostApiAuthLogin = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postApiAuthLogin>>, TError,{data: LoginRequest}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postApiAuthLogin>>,
        TError,
        {data: LoginRequest},
        TContext
      > => {

      const mutationOptions = getPostApiAuthLoginMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary Refresh access token
 */
export const postApiAuthRefresh = (
    refreshRequest: RefreshRequest,
 signal?: AbortSignal
) => {
      
      
      return axios<PostApiAuthRefresh200>(
      {url: `/api/auth/refresh`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: refreshRequest, signal
    },
      );
    }
  


export const getPostApiAuthRefreshMutationOptions = <TError = ErrorResponse | ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postApiAuthRefresh>>, TError,{data: RefreshRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof postApiAuthRefresh>>, TError,{data: RefreshRequest}, TContext> => {

const mutationKey = ['postApiAuthRefresh'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postApiAuthRefresh>>, {data: RefreshRequest}> = (props) => {
          const {data} = props ?? {};

          return  postApiAuthRefresh(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostApiAuthRefreshMutationResult = NonNullable<Awaited<ReturnType<typeof postApiAuthRefresh>>>
    export type PostApiAuthRefreshMutationBody = RefreshRequest
    export type PostApiAuthRefreshMutationError = ErrorResponse | ErrorResponse

    /**
 * @summary Refresh access token
 */
export const usePostApiAuthRefresh = <TError = ErrorResponse | ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postApiAuthRefresh>>, TError,{data: RefreshRequest}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postApiAuthRefresh>>,
        TError,
        {data: RefreshRequest},
        TContext
      > => {

      const mutationOptions = getPostApiAuthRefreshMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary Logout user and invalidate refresh token
 */
export const postApiAuthLogout = (
    logoutRequest: LogoutRequest,
 signal?: AbortSignal
) => {
      
      
      return axios<LogoutResponse>(
      {url: `/api/auth/logout`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: logoutRequest, signal
    },
      );
    }
  


export const getPostApiAuthLogoutMutationOptions = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postApiAuthLogout>>, TError,{data: LogoutRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof postApiAuthLogout>>, TError,{data: LogoutRequest}, TContext> => {

const mutationKey = ['postApiAuthLogout'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postApiAuthLogout>>, {data: LogoutRequest}> = (props) => {
          const {data} = props ?? {};

          return  postApiAuthLogout(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostApiAuthLogoutMutationResult = NonNullable<Awaited<ReturnType<typeof postApiAuthLogout>>>
    export type PostApiAuthLogoutMutationBody = LogoutRequest
    export type PostApiAuthLogoutMutationError = ErrorResponse

    /**
 * @summary Logout user and invalidate refresh token
 */
export const usePostApiAuthLogout = <TError = ErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postApiAuthLogout>>, TError,{data: LogoutRequest}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof postApiAuthLogout>>,
        TError,
        {data: LogoutRequest},
        TContext
      > => {

      const mutationOptions = getPostApiAuthLogoutMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * @summary Get current user profile
 */
export const getApiMe = (
    
 signal?: AbortSignal
) => {
      
      
      return axios<MeResponse>(
      {url: `/api/me`, method: 'GET', signal
    },
      );
    }
  

export const getGetApiMeQueryKey = () => {
    return [`/api/me`] as const;
    }

    
export const getGetApiMeQueryOptions = <TData = Awaited<ReturnType<typeof getApiMe>>, TError = ErrorResponse | ErrorResponse>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiMe>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetApiMeQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getApiMe>>> = ({ signal }) => getApiMe(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getApiMe>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetApiMeQueryResult = NonNullable<Awaited<ReturnType<typeof getApiMe>>>
export type GetApiMeQueryError = ErrorResponse | ErrorResponse


export function useGetApiMe<TData = Awaited<ReturnType<typeof getApiMe>>, TError = ErrorResponse | ErrorResponse>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiMe>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getApiMe>>,
          TError,
          Awaited<ReturnType<typeof getApiMe>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetApiMe<TData = Awaited<ReturnType<typeof getApiMe>>, TError = ErrorResponse | ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiMe>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getApiMe>>,
          TError,
          Awaited<ReturnType<typeof getApiMe>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetApiMe<TData = Awaited<ReturnType<typeof getApiMe>>, TError = ErrorResponse | ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiMe>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get current user profile
 */

export function useGetApiMe<TData = Awaited<ReturnType<typeof getApiMe>>, TError = ErrorResponse | ErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getApiMe>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetApiMeQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}


export const getPostApiAuthRegisterResponseMock = (overrideResponse: Partial< TokenResponse > = {}): TokenResponse => ({accessToken: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), refreshToken: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), ...overrideResponse})

export const getPostApiAuthLoginResponseMock = (overrideResponse: Partial< TokenResponse > = {}): TokenResponse => ({accessToken: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), refreshToken: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), ...overrideResponse})

export const getPostApiAuthRefreshResponseMock = (overrideResponse: Partial< PostApiAuthRefresh200 > = {}): PostApiAuthRefresh200 => ({accessToken: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), ...overrideResponse})

export const getPostApiAuthLogoutResponseMock = (overrideResponse: Partial< LogoutResponse > = {}): LogoutResponse => ({message: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), ...overrideResponse})

export const getGetApiMeResponseMock = (overrideResponse: Partial< MeResponse > = {}): MeResponse => ({id: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), email: faker.helpers.arrayElement([faker.string.alpha({length: {min: 10, max: 20}}), undefined]), ...overrideResponse})


export const getPostApiAuthRegisterMockHandler = (overrideResponse?: TokenResponse | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<TokenResponse> | TokenResponse)) => {
  return http.post('*/api/auth/register', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getPostApiAuthRegisterResponseMock()),
      { status: 201,
        headers: { 'Content-Type': 'application/json' }
      })
  })
}

export const getPostApiAuthLoginMockHandler = (overrideResponse?: TokenResponse | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<TokenResponse> | TokenResponse)) => {
  return http.post('*/api/auth/login', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getPostApiAuthLoginResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  })
}

export const getPostApiAuthRefreshMockHandler = (overrideResponse?: PostApiAuthRefresh200 | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<PostApiAuthRefresh200> | PostApiAuthRefresh200)) => {
  return http.post('*/api/auth/refresh', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getPostApiAuthRefreshResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  })
}

export const getPostApiAuthLogoutMockHandler = (overrideResponse?: LogoutResponse | ((info: Parameters<Parameters<typeof http.post>[1]>[0]) => Promise<LogoutResponse> | LogoutResponse)) => {
  return http.post('*/api/auth/logout', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getPostApiAuthLogoutResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  })
}

export const getGetApiMeMockHandler = (overrideResponse?: MeResponse | ((info: Parameters<Parameters<typeof http.get>[1]>[0]) => Promise<MeResponse> | MeResponse)) => {
  return http.get('*/api/me', async (info) => {await delay(1000);
  
    return new HttpResponse(JSON.stringify(overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(info) : overrideResponse)
    : getGetApiMeResponseMock()),
      { status: 200,
        headers: { 'Content-Type': 'application/json' }
      })
  })
}
export const getLoginAPIMock = () => [
  getPostApiAuthRegisterMockHandler(),
  getPostApiAuthLoginMockHandler(),
  getPostApiAuthRefreshMockHandler(),
  getPostApiAuthLogoutMockHandler(),
  getGetApiMeMockHandler()
]
